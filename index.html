<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>å‚™å¿˜éŒ„</title>

<style>
body{
  margin:0;
  font-family:-apple-system,system-ui;
  background:#f5f5f5;
}
header{
  padding:14px;
  font-size:22px;
  font-weight:600;
  display:flex;
  justify-content:space-between;
}
#noteList{
  padding:10px;
}
.note-item{
  background:#fff;
  border-radius:10px;
  padding:12px;
  margin-bottom:10px;
}
.note-title{
  font-size:16px;
  font-weight:500;
}
.note-sub{
  font-size:12px;
  color:#888;
}
#fab{
  position:fixed;
  right:18px;
  bottom:18px;
  width:56px;
  height:56px;
  border-radius:50%;
  background:#4a90e2;
  color:#fff;
  font-size:32px;
  display:flex;
  align-items:center;
  justify-content:center;
}
#editor{
  position:fixed;
  inset:0;
  background:#f5f5f5;
  display:none;
  flex-direction:column;
}
#editorHeader{
  background:#4a90e2;
  color:#fff;
  padding:10px;
  display:flex;
  justify-content:space-between;
}
#content{
  flex:1;
  padding:12px;
  background:#fff;
  margin:10px;
  border-radius:10px;
  border:1px solid #ccc;
  overflow:auto;
}
#topBar button{
  margin-left:6px;
}
</style>
</head>

<body>

<header id="topBar">
  <span>å‚™å¿˜éŒ„</span>
  <div>
    <button onclick="exportSecure()">åŠ å¯†åŒ¯å‡º</button>
    <button onclick="backupFile.click()">åŒ¯å…¥</button>
  </div>
</header>

<div id="noteList"></div>
<div id="fab" onclick="newNote()">ï¼‹</div>

<!-- Editor -->
<div id="editor">
  <div id="editorHeader">
    <button onclick="closeEditor()">è¿”å›</button>
    <button onclick="saveEditor()">å­˜æª”</button>
  </div>
  <div id="content" contenteditable="true"></div>
</div>

<input type="file" id="backupFile" accept=".json" hidden />

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<link rel="manifest" href="manifest.json">

<script>
/* ================= IndexedDB ================= */

const DB_NAME = "memoDB";
const STORE = "notes";
let db = null;
let currentId = null;

function openDB(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME,1);

    req.onupgradeneeded = e=>{
      const _db = e.target.result;
      if(!_db.objectStoreNames.contains(STORE)){
        _db.createObjectStore(STORE,{ keyPath:"id" });
      }
    };

    req.onsuccess = e=>{
      db = e.target.result;
      resolve();
    };

    req.onerror = e=>reject(e);
  });
}

function save(note){
  const tx = db.transaction(STORE,"readwrite");
  tx.objectStore(STORE).put(note);
}

function getAll(){
  return new Promise(resolve=>{
    const tx = db.transaction(STORE,"readonly");
    const req = tx.objectStore(STORE).getAll();
    req.onsuccess = ()=>resolve(req.result||[]);
  });
}

function remove(id){
  const tx = db.transaction(STORE,"readwrite");
  tx.objectStore(STORE).delete(id);
}

/* ================= List ================= */

async function refresh(){
  const list = document.getElementById("noteList");
  list.innerHTML = "";

  const notes = await getAll();

  notes
    .sort((a,b)=>b.timestamp-a.timestamp)
    .forEach(n=>{
      const div = document.createElement("div");
      div.className = "note-item";
      div.innerHTML = `
        <div class="note-title">${n.title||"ï¼ˆç„¡æ¨™é¡Œï¼‰"}</div>
        <div class="note-sub">${new Date(n.timestamp).toLocaleString()}</div>
      `;
      div.onclick = ()=>openEditor(n.id);
      list.appendChild(div);
    });
}

/* ================= Editor ================= */

async function openEditor(id){
  currentId = id;
  const notes = await getAll();
  const note = notes.find(n=>n.id===id);

  content.innerHTML = note?.content || "";

  editor.style.display = "flex";
  noteList.style.display = "none";
  fab.style.display = "none";
}

function closeEditor(){
  editor.style.display = "none";
  noteList.style.display = "";
  fab.style.display = "";
  currentId = null;
  refresh();
}

function saveEditor(){
  const text = content.innerText.trim();

  save({
    id: currentId || Date.now().toString(),
    title: text.slice(0,20),
    content: content.innerHTML,
    encrypted:false,
    timestamp: Date.now()
  });

  closeEditor();
}

function newNote(){
  currentId = null;
  content.innerHTML = "";
  openEditor(null);
}

/* ================= Export æ²’æœ‰åŠ å¯†çš„ç›´æ¥åŒ¯å‡º================= */

async function exportNotes(){
  const notes = await getAll();
  const blob = new Blob(
    [JSON.stringify(notes,null,2)],
    {type:"application/json"}
  );
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "notes_backup.json";
  a.click();
  URL.revokeObjectURL(a.href);
}

/* ================= Export ã€Œæœƒè·³å¯†ç¢¼ã€çš„åŒ¯å‡º================= */

async function exportSecure() {
  const password = prompt("è«‹è¼¸å…¥åŠ å¯†å¯†ç¢¼ï¼ˆè«‹å‹™å¿…è¨˜ä½ï¼‰");
  if (!password) return;

  const zipBlob = await buildZipBlob(); // å…ˆç”¢ç”Ÿ ZIP
  const encryptedBlob = await encryptBlob(zipBlob, password);

  // ğŸ‘‰ åŠ å¯†å¾Œå†é€²å…¥ã€Œåˆ†äº« / ä¸‹è¼‰ã€
  await shareOrDownload(
    encryptedBlob,
    "notes.secure",
    "application/octet-stream"
  );
}

/* =================ã€Œæœƒå‡ºç¾LocalSendã€ é—œéµå‡½å¼ ================= */

async function shareOrDownload(blob, filename, type) {
  const file = new File([blob], filename, { type });

  if (
    navigator.canShare &&
    navigator.canShare({ files: [file] })
  ) {
    // ğŸ‘‰ æ‰‹æ©Ÿæœƒè·³ã€Œåˆ†äº«é¢æ¿ã€
    await navigator.share({
      files: [file],
      title: "å‚™å¿˜éŒ„åŒ¯å‡º"
    });
  } else {
    // ğŸ‘‰ æ¡Œæ©Ÿ / ä¸æ”¯æ´å°±ä¸‹è¼‰
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
  }
}

/* ================= ZIP ç”¢ç”Ÿ(å¾ä½ ç¾æœ‰è³‡æ–™) ================= */

async function buildZipBlob() {
  const zip = new JSZip();
  const notes = await getAll();

  let html = `
<!DOCTYPE html><html><head><meta charset="utf-8">
<title>å‚™å¿˜éŒ„</title></head><body>
`;

  for (const n of notes) {
    const div = document.createElement("div");
    div.innerHTML = n.content;

    for (const media of div.querySelectorAll("img,video")) {
      if (!media.src.startsWith("data:")) continue;

      const res = await fetch(media.src);
      const blob = await res.blob();
      const ext = blob.type.split("/")[1];
      const name = `media/${crypto.randomUUID()}.${ext}`;

      zip.file(name, blob);
      media.src = name;
    }

    html += `<h2>${n.title}</h2>${div.innerHTML}<hr>`;
  }

  html += "</body></html>";
  zip.file("index.html", html);

  return zip.generateAsync({ type: "blob" });
}

/* ================= Import ================= */

backupFile.onchange = e=>{
  const file = e.target.files[0];
  if(!file) return;

  const reader = new FileReader();
  reader.onload = async ()=>{
    const data = JSON.parse(reader.result);
    if(!Array.isArray(data)){
      alert("æ ¼å¼éŒ¯èª¤");
      return;
    }
    data.forEach(n=>{
      save({
        ...n,
        id: Date.now().toString()+Math.random().toString(36).slice(2)
      });
    });
    refresh();
    alert("åŒ¯å…¥å®Œæˆ");
  };
  reader.readAsText(file);
};

/* ================= ZIP åŒ¯å‡ºå‡½å¼ ================= */

async function exportZip() {
  const zip = new JSZip();
  const notes = await getAll();

  let html = `
<!DOCTYPE html><html><head>
<meta charset="utf-8">
<title>å‚™å¿˜éŒ„åŒ¯å‡º</title>
<style>
body{font-family:system-ui;padding:20px;}
.note{margin-bottom:40px;}
</style>
</head><body>
`;

  for (const n of notes) {
    let content = n.content;

    // æŠ½å–åœ–ç‰‡ / å½±ç‰‡
    const div = document.createElement("div");
    div.innerHTML = content;

    for (const media of div.querySelectorAll("img,video")) {
      const src = media.src;
      if (!src.startsWith("data:")) continue;

      const res = await fetch(src);
      const blob = await res.blob();
      const ext = blob.type.split("/")[1];
      const name = `media/${crypto.randomUUID()}.${ext}`;

      zip.file(name, blob);
      media.src = name;
    }

    html += `
<div class="note">
  <h2>${n.title}</h2>
  ${div.innerHTML}
</div>`;
  }

  html += "</body></html>";
  zip.file("index.html", html);

  const blob = await zip.generateAsync({ type: "blob" });
  downloadBlob(blob, "notes.zip");
}

function downloadBlob(blob, filename) {
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
}

/* ================= åŠ å¯† ZIP åŒ¯å‡º ================= */

async function encryptAndExport(password) {
  const zipBlob = await (await fetchZipBlob()).blob();

  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));

  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(password),
    "PBKDF2",
    false,
    ["deriveKey"]
  );

  const key = await crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt"]
  );

  const encrypted = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    await zipBlob.arrayBuffer()
  );

  const out = new Blob([salt, iv, new Uint8Array(encrypted)]);
  downloadBlob(out, "notes.secure");
}

/* ================= çœŸæ­£æœ‰ç”¨çš„ AES åŠ å¯† (WebCrypto) ================= */

async function encryptBlob(blob, password) {
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));

  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(password),
    "PBKDF2",
    false,
    ["deriveKey"]
  );

  const key = await crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt"]
  );

  const encrypted = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    await blob.arrayBuffer()
  );

  return new Blob([salt, iv, new Uint8Array(encrypted)], {
    type: "application/octet-stream"
  });
}

/* ================= æœ€ä½³å¯¦å‹™ (å·²è¢«å¤§é‡PWA ä½¿ç”¨) LocalSend ================= */

async function shareZip() {
  const blob = await exportZipBlob();

  if (navigator.canShare && navigator.canShare({ files: [blob] })) {
    await navigator.share({
      files: [new File([blob], "notes.zip")],
      title: "å‚™å¿˜éŒ„åŒ¯å‡º"
    });
  } else {
    downloadBlob(blob, "notes.zip");
    alert("è«‹ä½¿ç”¨ LocalSend é¸å–æ­¤æª”æ¡ˆ");
  }
}


/* ================= PWA ================= */

if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("service-worker.js");
}

/* ================= Init ================= */

window.addEventListener("load",async()=>{
  await openDB();
  refresh();
});
</script>

</body>
</html>
