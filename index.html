<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>備忘錄</title>
  <style>
    body { margin:0; font-family:-apple-system,system-ui; background:#f5f5f5; }
    header { padding:14px; font-size:22px; font-weight:600; display:flex; justify-content:space-between; }
    #noteList { padding:10px; }
    .note-item { background:#fff; border-radius:10px; padding:12px; margin-bottom:10px; display:flex; justify-content:space-between; align-items:center; }
    .note-title { font-size:16px; font-weight:500; }
    .note-sub { font-size:12px; color:#888; }
    .delete-btn { background:#ff4d4d; color:#fff; padding:6px 12px; border:none; border-radius:5px; cursor:pointer; font-size:12px; }
    #fab { position:fixed; right:18px; bottom:18px; width:56px; height:56px; border-radius:50%; background:#4a90e2; color:#fff; font-size:32px; display:flex; align-items:center; justify-content:center; cursor:pointer; }
    #editor { position:fixed; inset:0; background:#f5f5f5; display:none; flex-direction:column; }
    #editorHeader { background:#4a90e2; color:#fff; padding:10px; display:flex; justify-content:space-between; }
    #content { flex:1; padding:12px; background:#fff; margin:10px; border-radius:10px; border:1px solid #ccc; overflow:auto; }
    #topBar button { margin-left:6px; }
  </style>
</head>
<body>

<header id="topBar">
  <span>備忘錄</span>
  <div>
    <button id="exportBtn">加密匯出</button>
    <button id="importBtn">匯入</button>
    <button id="undoBtn" style="display:none" onclick="undoDeleteAll()">復原</button>
    <button onclick="deleteAllNotes()">刪除所有備忘錄</button>
  </div>
</header>

<div id="noteList"></div>
<div id="fab" onclick="newNote()">＋</div>

<div id="editor">
  <div id="editorHeader">
    <button onclick="closeEditor()">返回</button>
    <button onclick="saveEditor()">存檔</button>
  </div>
  <div id="content" contenteditable="true"></div>
</div>

<!-- 匯入檔案 input -->
<input type="file" id="backupFile" accept=".json" style="display:none">

<script src="./jszip.min.js"></script>
<script src="./crypto-js.min.js"></script>

<script>
/* ================= IndexedDB ================= */
const DB_NAME = "memoDB";
const STORE = "notes";
let db = null;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = e => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains(STORE)) d.createObjectStore(STORE, { keyPath: "id" });
    };
    req.onsuccess = e => { db = e.target.result; resolve(); };
    req.onerror = reject;
  });
}

function save(note) { db.transaction(STORE, "readwrite").objectStore(STORE).put(note); }
function getAll() { return new Promise(res => { const r = db.transaction(STORE).objectStore(STORE).getAll(); r.onsuccess = () => res(r.result || []); }); }
function removeAll() { return new Promise((resolve, reject) => { const tx = db.transaction(STORE, "readwrite"); tx.objectStore(STORE).clear(); tx.oncomplete = () => resolve(); tx.onerror = () => reject(tx.error); }); }
function remove(id) { const tx = db.transaction(STORE, "readwrite"); tx.objectStore(STORE).delete(id); }

/* ================= CryptoJS ================= */
async function encryptBlob(blob, password) {
  const arrayBuffer = await blob.arrayBuffer();
  const wordArray = CryptoJS.lib.WordArray.create(arrayBuffer);
  const encrypted = CryptoJS.AES.encrypt(wordArray, password).toString();
  return new Blob([encrypted], { type: "application/octet-stream" });
}

async function decryptBlobCryptoJS(data, password) {
  const text = new TextDecoder().decode(data);
  const decrypted = CryptoJS.AES.decrypt(text, password);
  if (!decrypted.sigBytes || decrypted.sigBytes <= 0) throw new Error("CryptoJS decrypt failed");

  const words = decrypted.words;
  const bytes = new Uint8Array(decrypted.sigBytes);
  let offset = 0;
  for (let i = 0; i < words.length && offset < bytes.length; i++) {
    const w = words[i];
    for (let b = 3; b >= 0 && offset < bytes.length; b--) {
      bytes[offset++] = (w >> (8 * b)) & 0xff;
    }
  }
  return new Blob([bytes], { type: "application/json" });
}

/* ================= 匯出 ================= */
// 匯出並加密資料
async function exportSecure() {
  const password = prompt("請輸入密碼");
  if (!password) return;

  const notes = await getAll();
  const jsonStr = JSON.stringify(notes);

  // 使用 AES 加密
  const encrypted = CryptoJS.AES.encrypt(jsonStr, password).toString();

  // 使用 Base64 進行編碼，這裡確保使用正確的字符集
  const encryptedBase64 = CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(encrypted));

  // 存成 .json 檔案
  const blob = new Blob([encryptedBase64], { type: "application/json" });
  const file = new File([blob], "notes.secure.json", { type: "application/json" });

  // 桌機下載 / 手機分享
  if (navigator.canShare && navigator.canShare({ files: [file] }) && location.protocol !== "file:") {
    await navigator.share({ files: [file], title: "備忘錄匯出" });
  } else {
    downloadBlob(file, file.name);
  }
}

function downloadBlob(blob, filename) {
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  URL.revokeObjectURL(a.href);
  a.remove();
}


/* ================= 匯入 ================= */
// 匯入並解密資料
function importSecure(file) {
  const password = prompt("請輸入密碼");
  if (!password) return;

  const reader = new FileReader();
  reader.onload = async e => {
    try {
      let encrypted = e.target.result;

      // 移除 BOM 字符（某些手機瀏覽器會自動加入）
      encrypted = encrypted.replace(/^\uFEFF/, "").trim();

      // 解碼 Base64 字串
      const base64Decoded = CryptoJS.enc.Base64.parse(encrypted).toString(CryptoJS.enc.Utf8);

      // 解密並轉換為 UTF-8
      const decrypted = CryptoJS.AES.decrypt(base64Decoded, password);
      const jsonStr = decrypted.toString(CryptoJS.enc.Utf8);

      if (!jsonStr) throw new Error("解密失敗");

      // 解析解密後的資料
      const notes = JSON.parse(jsonStr);
      for (const note of notes) save(note);

      alert("✅ 匯入完成");
      refresh();
    } catch (err) {
      console.error(err);
      alert("❌ 匯入失敗：密碼錯誤或檔案已損毀");
    }
  };

  // 使用 UTF-8 編碼讀取檔案
  reader.readAsText(file, "UTF-8");
}


/* ================= refresh ================= */
async function refresh() {
  const list = document.getElementById("noteList");
  list.innerHTML = "";
  const notes = await getAll();
  notes.sort((a, b) => b.timestamp - a.timestamp).forEach(note => {
    const div = document.createElement("div");
    div.className = "note-item";
    div.innerHTML = `<div><div class="note-title">${note.title || "（無標題）"}</div><div class="note-sub">${new Date(note.timestamp).toLocaleString()}</div></div><button class="delete-btn">刪除</button>`;
    div.onclick = () => openEditor(note.id);
    div.querySelector(".delete-btn").onclick = e => {
      e.stopPropagation();
      if (confirm("確定刪除此備忘錄？")) {
        remove(note.id);
        refresh();
      }
    };
    list.appendChild(div);
  });
}

window.addEventListener("load", async () => {
  await openDB();
  refresh();

  const exportBtn = document.getElementById("exportBtn");
  const importBtn = document.getElementById("importBtn");
  const backupFile = document.getElementById("backupFile");

  // 判斷手機或桌機
  const isMobile = window.innerWidth <= 768;

  if (isMobile) {
    exportBtn.style.display = "none";   // 手機隱藏匯出
    importBtn.style.display = "inline-block"; // 手機顯示匯入
  } else {
    exportBtn.style.display = "inline-block"; // 桌機顯示匯出
    importBtn.style.display = "inline-block"; // 桌機顯示匯入
  }

  exportBtn.addEventListener("click", exportSecure);

  // 匯入流程
  importBtn.addEventListener("click", () => {
    backupFile.value = "";
    backupFile.click();
  });

  backupFile.addEventListener("change", () => {
    if (backupFile.files.length) importSecure(backupFile.files[0]);
  });
});
</script>

</body>
</html>
