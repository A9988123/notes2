<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>å‚™å¿˜éŒ„</title>
  <style>
    body {
      margin: 0;
      font-family: -apple-system, system-ui;
      background: #f5f5f5;
    }
    header {
      padding: 14px;
      font-size: 22px;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
    }
    #noteList {
      padding: 10px;
    }
    .note-item {
      background: #fff;
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .note-title {
      font-size: 16px;
      font-weight: 500;
    }
    .note-sub {
      font-size: 12px;
      color: #888;
    }
    .delete-btn {
      background: #ff4d4d;
      color: #fff;
      padding: 6px 12px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 12px;
    }
    #fab {
      position: fixed;
      right: 18px;
      bottom: 18px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: #4a90e2;
      color: #fff;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #editor {
      position: fixed;
      inset: 0;
      background: #f5f5f5;
      display: none;
      flex-direction: column;
    }
    #editorHeader {
      background: #4a90e2;
      color: #fff;
      padding: 10px;
      display: flex;
      justify-content: space-between;
    }
    #content {
      flex: 1;
      padding: 12px;
      background: #fff;
      margin: 10px;
      border-radius: 10px;
      border: 1px solid #ccc;
      overflow: auto;
    }
    #topBar button {
      margin-left: 6px;
    }
  </style>
</head>
<body>
  <header id="topBar">
    <span>å‚™å¿˜éŒ„</span>
    <div>
      <button id="exportBtn">åŠ å¯†åŒ¯å‡º</button>
      <button id="importBtn">åŒ¯å…¥</button>
      <button id="undoBtn" style="display:none" onclick="undoDeleteAll()">å¾©åŽŸ</button>
      <button onclick="deleteAllNotes()">åˆªé™¤æ‰€æœ‰å‚™å¿˜éŒ„</button>
    </div>
  </header>

  <div id="noteList"></div>
  <div id="fab" onclick="newNote()">ï¼‹</div>

  <div id="editor">
    <div id="editorHeader">
      <button onclick="closeEditor()">è¿”å›ž</button>
      <button onclick="saveEditor()">å­˜æª”</button>
    </div>
    <div id="content" contenteditable="true"></div>
  </div>

  <input type="file" id="backupFile" accept=".secure.zip,.json" style="display:none">


  <!-- å…ˆå¼•å…¥ CryptoJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1-crypto-js.min.js"></script>
  <!-- ç„¶å¾Œå¼•å…¥ JSZip -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <script>
    /* ================= IndexedDB ================= */
    const DB_NAME = "memoDB";
    const STORE = "notes";
    let db = null;

    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = e => {
          const d = e.target.result;
          if (!d.objectStoreNames.contains(STORE)) d.createObjectStore(STORE, { keyPath: "id" });
        };
        req.onsuccess = e => {
          db = e.target.result;
          resolve();
        };
        req.onerror = reject;
      });
    }

    function save(note) {
      db.transaction(STORE, "readwrite").objectStore(STORE).put(note);
    }

    function getAll() {
      return new Promise(res => {
        const r = db.transaction(STORE).objectStore(STORE).getAll();
        r.onsuccess = () => res(r.result || []);
      });
    }

    function removeAll() {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, "readwrite");
        tx.objectStore(STORE).clear();
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    function remove(id) {
      const tx = db.transaction(STORE, "readwrite");
      tx.objectStore(STORE).delete(id);
    }

    /* ================= build zip ================= */
    async function buildZipBlob() {
      const zip = new JSZip();
      const notes = await getAll();
      let html = `<!DOCTYPE html><html><head><meta charset="utf-8"><title>å‚™å¿˜éŒ„</title></head><body>`;
      for (const n of notes) {
        html += `<h2>${n.title || "ï¼ˆç„¡æ¨™é¡Œï¼‰"}</h2><div>${n.content || ""}</div><hr>`;
      }
      html += "</body></html>";
      zip.file("index.html", html);
      return zip.generateAsync({ type: "blob" });
    }

    /* ================= CryptoJS åŠ å¯†/è§£å¯† ================= */
    async function encryptBlob(blob, password) {
      const arrayBuffer = await blob.arrayBuffer();
      const wordArray = CryptoJS.lib.WordArray.create(arrayBuffer);
      const encrypted = CryptoJS.AES.encrypt(wordArray, password).toString();
      return new Blob([encrypted], { type: "application/octet-stream" });
    }

    async function decryptBlobCryptoJS(data, password) {
      const text = new TextDecoder().decode(data);
      const decrypted = CryptoJS.AES.decrypt(text, password);
      if (!decrypted.sigBytes || decrypted.sigBytes <= 0) throw new Error("CryptoJS decrypt failed");
      const words = decrypted.words;
      const bytes = new Uint8Array(decrypted.sigBytes);
      let offset = 0;
      for (let i = 0; i < words.length && offset < bytes.length; i++) {
        const w = words[i];
        for (let b = 3; b >= 0 && offset < bytes.length; b--) {
          bytes[offset++] = (w >> (8 * b)) & 0xff;
        }
      }
      return new Blob([bytes], { type: "application/zip" });
    }

    /* ================= exportSecure ================= */
async function exportSecure() {
// æª¢æŸ¥ CryptoJS æ˜¯å¦æ­£ç¢ºåŠ è¼‰
if (typeof CryptoJS === "undefined") {
  alert("âŒ CryptoJS æ²’æœ‰æ­£ç¢ºåŠ è¼‰ï¼");
  return;


  const password = prompt("è«‹è¼¸å…¥åŠ å¯†å¯†ç¢¼");
  if (!password) return;

  try {
    // å»ºç«‹åŠ å¯†æª”æ¡ˆ
    const zipBlob = await buildZipBlob();
    const encryptedBlob = await encryptBlob(zipBlob, password);
    const file = new File([encryptedBlob], "notes.secure.zip", { type: "application/octet-stream" });

    console.log("åŠ å¯†æª”æ¡ˆç”ŸæˆæˆåŠŸï¼Œé–‹å§‹è™•ç†ä¸‹è¼‰...");

    // å˜—è©¦ä¸‹è¼‰æª”æ¡ˆï¼ˆç§»é™¤ navigator.shareï¼‰
    downloadBlob(file, file.name);
  } catch (err) {
    console.error("åŒ¯å‡ºå¤±æ•—ï¼š", err);
    alert("âŒ åŒ¯å‡ºå¤±æ•—ï¼š" + err.message);
  }
}


function downloadBlob(blob, filename) {
  try {
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();
    console.log("æª”æ¡ˆä¸‹è¼‰æˆåŠŸ");
  } catch (err) {
    console.error("æª”æ¡ˆä¸‹è¼‰å¤±æ•—ï¼š", err);
    alert("âŒ æª”æ¡ˆä¸‹è¼‰å¤±æ•—ï¼š" + err.message);
  }
}



    /* ================= importSecure ================= */
    async function importSecure(file) {
      const password = prompt("è«‹è¼¸å…¥åŠ å¯†å¯†ç¢¼");
      if (!password) return;
      try {
        const data = new Uint8Array(await file.arrayBuffer());
        const zipBlob = await decryptBlobCryptoJS(data, password);
        const zip = await JSZip.loadAsync(zipBlob);
        const html = await zip.file("index.html").async("text");
        const div = document.createElement("div");
        div.innerHTML = html;
        [...div.querySelectorAll("h2")].forEach((h, i) => {
          save({ id: Date.now() + "_" + i, title: h.textContent, content: h.nextElementSibling?.innerHTML || "", timestamp: Date.now() });
        });
        alert("âœ… åŒ¯å…¥å®Œæˆ");
        refresh();
      } catch (err) {
        console.error(err);
        alert("âŒ è§£å¯†å¤±æ•—ï¼šå¯†ç¢¼éŒ¯èª¤æˆ–æª”æ¡ˆå·²ææ¯€");
      }
    }

    /* ================= refresh ================= */
    async function refresh() {
      const list = document.getElementById("noteList");
      list.innerHTML = "";
      const notes = await getAll();
      notes.sort((a, b) => b.timestamp - a.timestamp).forEach(note => {
        const div = document.createElement("div");
        div.className = "note-item";
        div.innerHTML = `<div><div class="note-title">${note.title || "ï¼ˆç„¡æ¨™é¡Œï¼‰"}</div><div class="note-sub">${new Date(note.timestamp).toLocaleString()}</div></div><button class="delete-btn">åˆªé™¤</button>`;
        div.onclick = () => openEditor(note.id);
        div.querySelector(".delete-btn").onclick = e => {
          e.stopPropagation();
          if (confirm("ç¢ºå®šåˆªé™¤æ­¤å‚™å¿˜éŒ„ï¼Ÿ")) {
            remove(note.id);
            refresh();
          }
        };
        list.appendChild(div);
      });
    }

    /* ================= æ–°å¢žã€ç·¨è¼¯ ================= */
    let currentId = null;

    async function newNote() {
      currentId = null;
      content.innerHTML = "";
      openEditor(null);
    }

    async function openEditor(id) {
      currentId = id;
      const notes = await getAll();
      const note = notes.find(n => n.id === id);
      document.getElementById("content").innerHTML = note?.content || "";
      document.getElementById("editor").style.display = "flex";
      document.getElementById("noteList").style.display = "none";
      document.getElementById("fab").style.display = "none";
    }

    function closeEditor() {
      editor.style.display = "none";
      noteList.style.display = "";
      fab.style.display = "";
      currentId = null;
      refresh();
    }

    function saveEditor() {
      const text = content.innerText.trim();
      save({ id: currentId || Date.now().toString(), title: text.slice(0, 20), content: content.innerHTML, timestamp: Date.now() });
      closeEditor();
    }

    /* ================= åˆªé™¤å…¨éƒ¨ + Undo ================= */
    let lastDeletedNotes = null;
    let undoTimer = null;

    async function deleteAllNotes() {
      if (!confirm("âš ï¸ ç¢ºå®šåˆªé™¤æ‰€æœ‰å‚™å¿˜éŒ„ï¼Ÿ")) return;
      lastDeletedNotes = await getAll();
      await removeAll();
      refresh();
      const undoBtn = document.getElementById("undoBtn");
      undoBtn.style.display = "inline-block";
      clearTimeout(undoTimer);
      undoTimer = setTimeout(() => {
        lastDeletedNotes = null;
        undoBtn.style.display = "none";
      }, 10000);
      alert("ðŸ§¹ å·²åˆªé™¤ï¼Œå¯æ–¼ 10 ç§’å…§å¾©åŽŸ");
    }

    async function undoDeleteAll() {
      if (!lastDeletedNotes || !lastDeletedNotes.length) return;
      for (const note of lastDeletedNotes) save(note);
      lastDeletedNotes = null;
      document.getElementById("undoBtn").style.display = "none";
      refresh();
      alert("â†©ï¸ å·²å¾©åŽŸ");
    }

    /* ================= å•Ÿå‹• ================= */
    window.addEventListener("load", async () => {
      await openDB();
      refresh();
      document.getElementById("exportBtn").addEventListener("click", exportSecure);
      const importBtn = document.getElementById("importBtn");
      const backupFile = document.getElementById("backupFile");
      importBtn.addEventListener("click", () => {
        backupFile.value = "";
        backupFile.click();
      });
      backupFile.addEventListener("change", () => {
        if (backupFile.files.length) importSecure(backupFile.files[0]);
      });
    });
  </script>
</body>
</html>
