<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>å‚™å¿˜éŒ„</title>
  <style>
    body{
      margin:0;
      font-family:-apple-system,system-ui;
      background:#f5f5f5;
    }
    header{
      padding:14px;
      font-size:22px;
      font-weight:600;
      display:flex;
      justify-content:space-between;
    }
    #noteList{
      padding:10px;
    }
    .note-item{
      background:#fff;
      border-radius:10px;
      padding:12px;
      margin-bottom:10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .note-title{
      font-size:16px;
      font-weight:500;
    }
    .note-sub{
      font-size:12px;
      color:#888;
    }
    .delete-btn {
      background: #ff4d4d;
      color: #fff;
      padding: 6px 12px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 12px;
    }
    #fab{
      position:fixed;
      right:18px;
      bottom:18px;
      width:56px;
      height:56px;
      border-radius:50%;
      background:#4a90e2;
      color:#fff;
      font-size:32px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #editor{
      position:fixed;
      inset:0;
      background:#f5f5f5;
      display:none;
      flex-direction:column;
    }
    #editorHeader{
      background:#4a90e2;
      color:#fff;
      padding:10px;
      display:flex;
      justify-content:space-between;
    }
    #content{
      flex:1;
      padding:12px;
      background:#fff;
      margin:10px;
      border-radius:10px;
      border:1px solid #ccc;
      overflow:auto;
    }
    #topBar button{
      margin-left:6px;
    }
  </style>
</head>

<body>

<header id="topBar">
  <span>å‚™å¿˜éŒ„</span>
  <div>
    <button id="exportBtn">åŠ å¯†åŒ¯å‡º</button>
    <button id="importBtn">åŒ¯å…¥</button>
    <button id="undoBtn" style="display:none"onclick="undoDeleteAll()">å¾©åŸ</button>
    <button onclick="deleteAllNotes()">åˆªé™¤æ‰€æœ‰å‚™å¿˜éŒ„</button>
    <button id="undoBtn" onclick="undoDeleteAll()" style="display:none">å¾©åŸ</button>
  </div>
</header>

<div id="noteList"></div>
<div id="fab" onclick="newNote()">ï¼‹</div>


<div id="editor">
  <div id="editorHeader">
    <button onclick="closeEditor()">è¿”å›</button>
    <button onclick="saveEditor()">å­˜æª”</button>
  </div>
  <div id="content" contenteditable="true"></div>
</div>


<input
  type="file"
  id="backupFile"
  accept=".json,.secure"
  style="display:none"
/>

<script src="./jszip.min.js"></script>
<script src="./crypto-js.min.js"></script>

<style>

#fab{
  position:fixed;
  right:18px;
  bottom:18px;
  width:56px;
  height:56px;
  border-radius:50%;
  background:#4a90e2;
  color:#fff;
  font-size:32px;
  display:flex;
  align-items:center;
  justify-content:center;
}
</style>

<script>
/* ================= IndexedDB ================= */
const DB_NAME = "memoDB";
const STORE = "notes";
let db = null;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = e => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains(STORE)) {
        d.createObjectStore(STORE, { keyPath: "id" });
      }
    };
    req.onsuccess = e => {
      db = e.target.result;
      resolve();
    };
    req.onerror = reject;
  });
}

function save(note) {
  db.transaction(STORE, "readwrite").objectStore(STORE).put(note);
}

function getAll() {
  return new Promise(res => {
    const r = db.transaction(STORE).objectStore(STORE).getAll();
    r.onsuccess = () => res(r.result || []);
  });
}

function removeAll() {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readwrite");
    tx.objectStore(STORE).clear();
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

function remove(id) {
  const tx = db.transaction(STORE, "readwrite");
  tx.objectStore(STORE).delete(id);
}

/* ================= ç¢ºä¿ exportSecure æ˜¯å…¨åŸŸ function ================= */

async function exportSecure() {
  console.log("ğŸ“¤ exportSecure called");

  try {
    console.log("1ï¸âƒ£ build zip");
    const zipBlob = await buildZipBlob();

    const password = prompt("è«‹è¼¸å…¥åŠ å¯†å¯†ç¢¼");
    if (!password) return;

    console.log("2ï¸âƒ£ encrypt");
    const encryptedBlob = await encryptBlob(zipBlob, password);

    console.log("3ï¸âƒ£ done", encryptedBlob);

    // âœ… ä¸‹è¼‰
    downloadBlob(encryptedBlob, "notes.secure");

    alert("âœ… åŒ¯å‡ºå®Œæˆ");

  } catch (err) {
    console.error("âŒ export error:", err);
    alert("âŒ åŒ¯å‡ºå¤±æ•—ï¼š" + (err.message || err));
  }
}




function downloadBlob(blob, filename) {
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  URL.revokeObjectURL(a.href);
  a.remove();
}

async function buildZipBlob() {
  const zip = new JSZip();
  const notes = await getAll();

  let html = `
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>å‚™å¿˜éŒ„</title>
</head>
<body>
`;

  for (const n of notes) {
    html += `<h2>${n.title || "ï¼ˆç„¡æ¨™é¡Œï¼‰"}</h2>`;
    html += `<div>${n.content || ""}</div><hr>`;
  }

  html += "</body></html>";

  zip.file("index.html", html);
  return zip.generateAsync({ type: "blob" });
}

/* ================= iOS ç©©å®š promptï¼ˆä½ ä¹‹å‰å·²ç¶“ç”¨éï¼‰ ================= */

function safePrompt(msg) {
  return new Promise(res => {
    setTimeout(() => res(prompt(msg)), 50);
  });
}

/* ================= åŒ¯å…¥è§£å¯† ================= */
function canUseWebCrypto() {
  return location.protocol === "https:" && crypto?.subtle;
}

async function decryptBlobWebCrypto(data, password) {
  const salt = data.slice(0, 16);
  const iv = data.slice(16, 28);
  const body = data.slice(28);

  const keyMat = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(password),
    "PBKDF2",
    false,
    ["deriveKey"]
  );

  const key = await crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
    keyMat,
    { name: "AES-GCM", length: 256 },
    false,
    ["decrypt"]
  );

  const buf = await crypto.subtle.decrypt(
    { name: "AES-GCM", iv },
    key,
    body
  );

  return new Blob([buf], { type: "application/zip" });
}


/* ================= importSecure ================= */

async function importSecure(file) {
  console.log("ğŸ”¥ importSecure", file.name);

  const password = prompt("è«‹è¼¸å…¥åŠ å¯†å¯†ç¢¼");
  if (!password) return;

  const data = new Uint8Array(await file.arrayBuffer());
  let zipBlob;

  try {
    // å…ˆè©¦ WebCryptoï¼ˆæ–°ç‰ˆï¼‰
    zipBlob = await decryptBlobWebCrypto(data, password);
  } catch (e1) {
    try {
      // å†è©¦ CryptoJSï¼ˆèˆŠç‰ˆï¼‰
      zipBlob = await decryptBlobCryptoJS(data, password);
    } catch (e2) {
      console.error(e1, e2);
      alert("âŒ è§£å¯†å¤±æ•—ï¼šå¯†ç¢¼éŒ¯èª¤æˆ–æª”æ¡ˆå·²ææ¯€");
      return;
    }
  }

  const zip = await JSZip.loadAsync(zipBlob);
  const html = await zip.file("index.html").async("text");

  const div = document.createElement("div");
  div.innerHTML = html;

  [...div.querySelectorAll("h2")].forEach((h, i) => {
    save({
      id: Date.now() + "_" + i,
      title: h.textContent,
      content: h.nextElementSibling?.innerHTML || "",
      timestamp: Date.now()
    });
  });

  alert("âœ… åŒ¯å…¥å®Œæˆ");
  refresh();
}

/* ================= æœ€ç©©å®šç‰ˆæœ¬ï¼Œå…ˆåˆ¥åˆ† fallback ================= */

async function encryptBlob(blob, password) {
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));

  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(password),
    "PBKDF2",
    false,
    ["deriveKey"]
  );

  const key = await crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt"]
  );

  const encrypted = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    await blob.arrayBuffer()
  );

  return new Blob([salt, iv, new Uint8Array(encrypted)], {
    type: "application/octet-stream"
  });
}


/* ================= newNote ================= */

function newNote() {
  currentId = null;
  content.innerHTML = "";
  openEditor(null);
}

/* ================= è«‹ç›´æ¥åŠ å…¥é€™å€‹ CryptoJS è§£å¯†å‡½å¼ ================= */

async function decryptBlobCryptoJS(data, password) {
  const text = new TextDecoder().decode(data);
  const decrypted = CryptoJS.AES.decrypt(text, password);

  if (!decrypted.sigBytes || decrypted.sigBytes <= 0) {
    throw new Error("CryptoJS decrypt failed");
  }

  const words = decrypted.words;
  const bytes = new Uint8Array(decrypted.sigBytes);

  let offset = 0;
  for (let i = 0; i < words.length && offset < bytes.length; i++) {
    const w = words[i];
    for (let b = 3; b >= 0 && offset < bytes.length; b--) {
      bytes[offset++] = (w >> (8 * b)) & 0xff;
    }
  }

  return new Blob([bytes], { type: "application/zip" });
}

/* =================è£œå›ã€Œå®Œæ•´å¯ç”¨çš„ refresh()ã€â­â­â­================= */

async function refresh() {
  const list = document.getElementById("noteList");
  list.innerHTML = "";

  const notes = await getAll();

  notes
    .sort((a, b) => b.timestamp - a.timestamp)
    .forEach(note => {
      const div = document.createElement("div");
      div.className = "note-item";

      div.innerHTML = `
        <div>
          <div class="note-title">${note.title || "ï¼ˆç„¡æ¨™é¡Œï¼‰"}</div>
          <div class="note-sub">${new Date(note.timestamp).toLocaleString()}</div>
        </div>
        <button class="delete-btn">åˆªé™¤</button>
      `;

      // é»æ•´å¼µå¡ç‰‡ â†’ ç·¨è¼¯
      div.onclick = () => openEditor(note.id);

      // é»åˆªé™¤ â†’ åªåˆªé™¤ï¼Œä¸é€²ç·¨è¼¯
      div.querySelector(".delete-btn").onclick = e => {
        e.stopPropagation();
        if (confirm("ç¢ºå®šåˆªé™¤æ­¤å‚™å¿˜éŒ„ï¼Ÿ")) {
          remove(note.id);
          refresh();
        }
      };

      list.appendChild(div);
    });
}

/* =================åˆªé™¤å…¨éƒ¨ï¼ˆå« undo åŸºç¤ï¼‰==ğŸ‘‰ é€™æ¨£æ‰æ˜¯**ã€Œæç¤º + å¯¦éš›æ“ä½œã€å®Œæ•´ UX**=========== */

let lastDeletedNotes = null;
let undoTimer = null;

async function deleteAllNotes() {
  if (!confirm("âš ï¸ ç¢ºå®šåˆªé™¤æ‰€æœ‰å‚™å¿˜éŒ„ï¼Ÿ")) return;

  lastDeletedNotes = await getAll();

  await removeAll();        // ğŸ”´ ä¸€å®šè¦ await
  refresh();

  const undoBtn = document.getElementById("undoBtn");
  undoBtn.style.display = "inline-block";

  clearTimeout(undoTimer);
  undoTimer = setTimeout(() => {
    lastDeletedNotes = null;
    undoBtn.style.display = "none";
  }, 10000);

  alert("ğŸ§¹ å·²åˆªé™¤ï¼Œå¯æ–¼ 10 ç§’å…§å¾©åŸ");
}

/* =================undoDeleteAll() ä¹Ÿè¦ç¢ºä¿é †åºæ­£ç¢º ================= */

async function undoDeleteAll() {
  if (!lastDeletedNotes || !lastDeletedNotes.length) return;

  for (const note of lastDeletedNotes) {
    await save(note);   // è‹¥ save ä¸æ˜¯ asyncï¼Œä¹Ÿ OK
  }

  lastDeletedNotes = null;
  document.getElementById("undoBtn").style.display = "none";
  refresh();

  alert("â†©ï¸ å·²å¾©åŸ");
}

/* =================è£œé½Š Editor JSï¼ˆä½ å¯ä»¥ç›´æ¥è²¼ï¼‰ ================= */

let currentId = null;

async function openEditor(id) {
  currentId = id;
  const notes = await getAll();
  const note = notes.find(n => n.id === id);

  document.getElementById("content").innerHTML = note?.content || "";
  document.getElementById("editor").style.display = "flex";
  document.getElementById("noteList").style.display = "none";
  document.getElementById("fab").style.display = "none";
}

function closeEditor() {
  editor.style.display = "none";
  noteList.style.display = "";
  fab.style.display = "";
  currentId = null;
  refresh();
}

function saveEditor() {
  const text = content.innerText.trim();

  save({
    id: currentId || Date.now().toString(),
    title: text.slice(0, 20),
    content: content.innerHTML,
    timestamp: Date.now()
  });

  closeEditor(); // closeEditor è£¡ refresh ä¸€æ¬¡å°±å¥½
}

/* ================= å•Ÿå‹• ================= */

window.addEventListener("load", async () => {
  console.log("âœ… app load");

  await openDB();
  refresh();

  document.getElementById("exportBtn").addEventListener("click", exportSecure);

  const importBtn = document.getElementById("importBtn");
  const backupFile = document.getElementById("backupFile");

  importBtn.addEventListener("click", () => {
    backupFile.value = "";
    backupFile.click();
  });

  backupFile.addEventListener("change", () => {
    if (backupFile.files.length) {
      importSecure(backupFile.files[0]);
    }
  });
});

</script>


</body>
</html>
